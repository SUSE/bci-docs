<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Guides on SUSE Linux BCI Documentation</title><link>https://opensource.suse.com/bci-docs/guides/</link><description>Recent content in Guides on SUSE Linux BCI Documentation</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://opensource.suse.com/bci-docs/guides/index.xml" rel="self" type="application/rss+xml"/><item><title>Adding Users to SLE BCI Micro and Minimal</title><link>https://opensource.suse.com/bci-docs/guides/adding-users/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/adding-users/</guid><description>&lt;div class="paragraph">



&lt;blockquote class="gdoc-hint note">
 &lt;div class="gdoc-hint__title flex gap-8 align-center">&lt;i class="fa note">&lt;/i>
 &lt;span>Note&lt;/span>&lt;/div>
 &lt;div class="gdoc-hint__text">This guide will demonstrate how to add users to the SLE BCI Micro and SLE BCI Minimal
images, without having the &lt;code>useradd&lt;/code> binary installed.&lt;/div>
&lt;/blockquote>

&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_background">Background&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The SLE BCI Micro and Minimal images are tailored towards providing a small
footprint and thus do not ship the &lt;code>useradd&lt;/code> binary. While this reduces the
image size, creating new users inside containers based on BCI Micro or Minimal
involves a few additional steps.&lt;/p>
&lt;/div></description></item><item><title>Building and Deploying Go Applications</title><link>https://opensource.suse.com/bci-docs/guides/use-with-golang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/use-with-golang/</guid><description>&lt;div class="paragraph">
&lt;p>There is &lt;a href="https://registry.suse.com/static/bci/golang/index.html">a
SLE BCI that can be used with the Go programming language&lt;/a>. There are a
couple different recommended methods to work with the Go SLE BCI.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_dont_ship_the_compiler">Don’t Ship The Compiler&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Go is a compiled language producing a binary as the end result. That
means the compiler does not need to be shipped as part of the images
that are distributed. Instead, it is recommended that the Go image is
used as the builder image only.&lt;/p>
&lt;/div></description></item><item><title>Building Container Images Based on SLE BCI</title><link>https://opensource.suse.com/bci-docs/guides/building-on-top-of-bci/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/building-on-top-of-bci/</guid><description>&lt;div class="paragraph">
&lt;p>In the container ecosystem, many tools can work with OCI-compliant images,
and all of them can use our Base Container Images.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_using_with_docker_podman_or_nerdctl">Using with Docker, Podman or nerdctl&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The Base Container Images are OCI-compliant, and you can use them
directly in your &lt;code>Dockerfile&lt;/code> or &lt;code>Containerfile&lt;/code> without any modifications.
All you need to do is include the image in the &lt;code>FROM&lt;/code> line as follows:&lt;/p>
&lt;/div>
&lt;div class="listingblock">
&lt;div class="content">
&lt;pre class="highlight">&lt;code class="language-Dockerfile" data-lang="Dockerfile">FROM registry.suse.com/bci/nodejs:latest as node-builder
WORKDIR /app/
COPY . /app/

RUN npm install &amp;amp;&amp;amp; npm run build&lt;/code>&lt;/pre>
&lt;/div></description></item><item><title>Deploy an Application using zypper</title><link>https://opensource.suse.com/bci-docs/guides/deploy-using-zypper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/deploy-using-zypper/</guid><description>&lt;div class="sect1">
&lt;h2 id="_scope">Scope&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>The purpose of this guide is to deploy an application or the dependencies of an
application from rpms into a deployment image using the zypper package manager.&lt;/p>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_using_zyppers_custom_root">Using zypper’s custom root&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Zypper provides the &lt;code>--installroot&lt;/code> flag to install packages into a custom root
and not use &lt;code>/&lt;/code>. We can leverage this to install packages including all of their
dependencies into a custom root and then copy this directory into a deployment
image. In the following example we install &lt;code>apache2&lt;/code> including all of its
dependencies and copy them into the deployment image based on &lt;code>bci-micro&lt;/code>:&lt;/p>
&lt;/div></description></item><item><title>How to build a distroless image using SLE BCI</title><link>https://opensource.suse.com/bci-docs/guides/building-a-distroless-image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/building-a-distroless-image/</guid><description>&lt;div class="sect1">
&lt;h2 id="_what_is_a_distroless_image">What is a distroless image?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>Distroless images are stripped down container images, where the underlying Linux
distribution is reduced to the bare minimum. A distroless image normally
contains only certificates and specific core libraries, and it does not include
a shell or utilities like &lt;code>cat&lt;/code> or &lt;code>ls&lt;/code>.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The advantages of distroless images include smaller size and potentially fewer
vulnerabilities.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>The major disadvantage is the difficulty of debugging a containerized
application, as the container image does not provide any debugging tools and may
even lack tools to read log files. Debugging applications usually requires
attaching sidecar containers or interacting with the container via the &lt;code>/proc/&lt;/code>
filesystem. For this reason, we recommend to use SLE BCI Base, SLE BCI Micro or
SLE BCI BusyBox as the deployment image, because they make debugging easier, and
they come with a valid rpm database.&lt;/p>
&lt;/div></description></item><item><title>How to use container-suseconnect</title><link>https://opensource.suse.com/bci-docs/guides/container-suseconnect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/container-suseconnect/</guid><description>&lt;div class="sect1">
&lt;h2 id="_what_is_container_suseconnect">What is container-suseconnect?&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>&lt;a href="https://github.com/SUSE/container-suseconnect">&lt;code>container-suseconnect&lt;/code>&lt;/a>
is a plugin available in all Base Container Images that ship with
Zypper. When the plugin detects the host’s SUSE Linux Enterprise Server
registration credentials, it uses them to give the container access the
SUSE Linux Enterprise repositories. This includes additional modules and
previous package versions that are not part of the free SLE_BCI
repository.&lt;/p>
&lt;/div>
&lt;div class="sect2">
&lt;h3 id="_how_to_use_container_suseconnect">How to use container-suseconnect&lt;/h3>
&lt;div class="paragraph">
&lt;p>If you are running a registered SLES system with Docker,
&lt;code>container-suseconnect&lt;/code> automatically detects and uses the subscription,
without requiring any action on your part.&lt;/p>
&lt;/div></description></item><item><title>How To Use SLE BCIs As VScode Development Containers</title><link>https://opensource.suse.com/bci-docs/guides/vscode-dev-containers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/vscode-dev-containers/</guid><description>&lt;div class="paragraph">
&lt;div class="flex justify-center">
 &lt;figure class="gdoc-markdown__figure">
 &lt;a class="gdoc-markdown__link--raw" href="https://opensource.suse.com/bci-docs/guides/vscode-dev-containers/vscode.png">
 &lt;picture>
 &lt;source
 srcset="https://opensource.suse.com/bci-docs/guides/vscode-dev-containers/vscode_hu_42091249c3f6dcab.png"
 />
 &lt;img
 src="https://opensource.suse.com/bci-docs/guides/vscode-dev-containers/vscode_hu_42091249c3f6dcab.png"
 alt="VS Code with the source mounted in a Development Container. The open terminal is a console within the container."
 />
 &lt;/picture>
 &lt;/a>
 &lt;figcaption>
 VS Code with the source mounted in a Development Container. The open terminal is a console within the container.
 &lt;/figcaption>
 &lt;/figure>
 &lt;/div>

&lt;/div>
&lt;div class="paragraph">
&lt;p>Visual Studio Code has a feature called
&lt;a href="https://code.visualstudio.com/docs/remote/create-dev-container">Development
Containers&lt;/a>. This is part of the built-in functionality to work with
remote containers. The Language Stack SLE BCIs make a great choice to
use as a development environment.&lt;/p>
&lt;/div></description></item><item><title>Image Verification</title><link>https://opensource.suse.com/bci-docs/guides/image-verification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/image-verification/</guid><description>&lt;div class="paragraph">
&lt;p>Verifying container images allows you to confirm their provenance, ensuring
supply chain security, and making sure that the software is what it claims to be.&lt;/p>
&lt;/div>
&lt;div class="paragraph">
&lt;p>You can verify SUSE Linux Base Container Images using
&lt;a href="https://www.sigstore.dev/">Sigstore&lt;/a>
&lt;a href="https://docs.sigstore.dev/cosign/verifying/verify/">Cosign&lt;/a>.&lt;/p>
&lt;/div>
&lt;div class="sect1">
&lt;h2 id="_downloading_cosign">Downloading Cosign&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>There are multiple places to get Cosign from:&lt;/p>
&lt;/div>
&lt;div class="ulist">
&lt;ul>
&lt;li>
&lt;p>As a package from SLES/openSUSE repositories&lt;/p>
&lt;/li>
&lt;li>
&lt;p>As a container image from &lt;code>ghcr.io/sigstore/cosign/cosign&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>As a container image from &lt;code>registry.suse.com/suse/cosign&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/div>
&lt;div class="paragraph">
&lt;p>For the examples in this documentation, we will use
&lt;a href="https://registry.suse.com/repositories/suse-cosign">SUSE Linux BCI Cosign&lt;/a>
from the SUSE Registry.&lt;/p>
&lt;/div></description></item><item><title>Launch Containers with Podman and Systemd</title><link>https://opensource.suse.com/bci-docs/guides/podman-generate-systemd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/podman-generate-systemd/</guid><description>&lt;div class="sect1">
&lt;h2 id="_local_container_orchestration">Local Container Orchestration&lt;/h2>
&lt;div class="sectionbody">
&lt;div class="paragraph">
&lt;p>A container runtime makes it easy to launch an application distributed as a
single container. But things get more complicated when you need to run
applications consisting of multiple containers, or when it’s necessary to start
the applications automatically on system boot and restart them after they
crash. While container orchestration tools like Kubernetes are designed for that
exact purpose, they are intended to be used for highly distributed and scalable
systems with hundreds of nodes, and not for a single machine. systemd and Podman
are much better suited for the single-machine scenario, as they do not add
another layer complexity to your existing setup.&lt;/p>
&lt;/div></description></item><item><title>Package Management</title><link>https://opensource.suse.com/bci-docs/guides/package-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://opensource.suse.com/bci-docs/guides/package-management/</guid><description>&lt;div class="paragraph">
&lt;p>&lt;a href="https://documentation.suse.com/smart/systems-management/html/concept-zypper/index.html">Zypper&lt;/a>
is the default package manager in SUSE Linux Base Container Images. Like
&lt;a href="https://wiki.debian.org/AptCLI">APT&lt;/a> in Debian/Ubuntu or
&lt;a href="https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper">APK&lt;/a> in Alpine Linux,
Zypper offers a command-line interface for all package management tasks.
Below is a brief overview of commonly used container-related Zypper commands.&lt;/p>
&lt;/div>
&lt;div class="admonitionblock note">
&lt;table>
&lt;tbody>&lt;tr>
&lt;td class="icon">
&lt;div class="title">Note&lt;/div>
&lt;/td>
&lt;td class="content">
Zypper is available on selected container images. Application stack
containers do not include a package manager, as well as SUSE Linux BCI Micro,
SUSE Linux BCI Minimal and SUSE Linux BCI BusyBox.
&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;/div></description></item></channel></rss>